
# u = mda.Universe(self['EX.gro'].s, self['1/md_center.xtc'].s)
# u.trajectory[-1]
# protein = u.select_atoms('protein') # TODO ATOM NUMBERING MAY BE WRONG!!!
# ligand = u.select_atoms('resname UNL')
# ligand_gro = ligand.write(self.unl_acpype['ligand_after_4.gro'].s)

# self.unl_acpype['lig.mol2'].t









# t.kid.kid.kid.rm()
# t.kid.kid.kid.
# t.rm()
# t.ls
# t
# jj
# t.rdv('lit_at_pairs')
# t.launch()
# tkkkk
# t.run_mopac()
# t.mop_opt()
# t.mp.ls
# t.prepare_kids()
# t.kid.launch()

# t.kid.prepare_kids()
# t.kid.kid.launch()
# t._lig_prot_initialize()
# jo
# t._lig_prot_initialize(make_ES_pdb=1, make_X_pdb=1)
# t.run_spores()
# t.launc9Go
# args.X_pdb.t
# P('/home/domain/data/rustam/dgfl/str/1xww_prot.pdb').t
# args.E_pdb.t


# t.launch_kids()

# t.launch()
# t__dir.ls
# tjj.rwdir()
# t.cd
# t._dir_initialize()
# t._lig_prot_initialize()
# t.run_spores(db=0)
# t.run_mopac()
# t.prepare_kids()
# t.kid.launch()
# t.kid.write

# self
# []
# self
# print('kjkj')

# self

# t = P(cur_ser.d_a[ln])


# self.prepare_kids()
# args.X_pdb.t
# t.XH_pdb.t
# self.mp.joinpath('lig-2.mol2').t
# self.mp.joinpath('lig.mol2').t
# t.mop_out_to_mol2()
# self.launch()
# self.prepare_kids()
# self.kid.launch()
# self.kid.run_ed()
# self.make_visu_df()

# self.prepare_kids()
# self.launch()
# self

# self.launch_kids()

# self
# self
# t.kid.
# t.rdv('lit_at_pairs')
# t.kid.rdv('lit_at_pairs')
# args.lit_at_pairs
# self.gpp_md()
# self.heat_atoms()
# args.E_pdb.l
# args.X_pdb.l
# t.XH_pdb.l
# t.[j]
# [*d_a.rglob('HR*')]
# t['mp']
# t.kid['str/prot.lig.mol2'].l
# t.kid.kid['EX.gro'].l
# pmr()
# P("/home/domain/data/rustam/A1/RESERVER_08_12_2020_05_13L_PI35P/str/XH.pdb").l
# P("/home/domain/data/rustam/A1/RESERVER_08_12_2020_05_13L_PI35P/str/E.pdb").l
# args.XH_pdb.l

# t.

# d__sdir["1xww_prot.pdb"].s
# /home/domain/data/rustam/dgfl/str/L_PI35P_E.pdb
# args.XH_pdb.t
# d__sdir["1xww_prot.pdb"]
# self._lig_prot_initialize(1, 1)
# d__sdir["L_PI35P_E.pdb"].l

# args.lit_at_pairs


# t._dir_initialize()
# t._lig_prot_initialize()
# t,c1k
# t
# t.kid.
# self.pld.make_visu()
# self.pld.pse.l
# self.pld['load /r/A1/L_PI35P/PL_0__1/']
# self['str/prot.mol2'].l
# self.pld.ls
# t.E_pdb.l
# t.XH_pdb.t
# self['']
# P('/home/domain/data/rustam/A1/L_PI35P/PL_0__1/pld_results_c_A_n_1_flex_0/lig.out_entry_00001_conf_01.mol2').l
# P('/home/domain/data/rustam/A1/L_PI35P/PL_0__1/pld_results_c_A_n_1_flex_0/lig.out_entry_00001_conf_01_protein.mol2').l

# P('/home/domain/data/rustam/A1/L_PI35P/PL_0__1/pld_results_c_A_n_1_flex_0/lig.out_entry_00001_conf_01.mol2').t


#         # # VISU CONTACTS:
#         # cmds_pml = [f'load {self.XH_pdb}', f'load {self.E_pdb}']
#         # for i, (cat_E_at_lst, cat_X_at_lst) in enumerate(lit_at_pairs):
#         #     cmds_pml += [
#         #         f'select pair_{i}_prot, i. {cat_E_at_lst[0]} & n. {cat_E_at_lst[1]}',
#         #         f'select pair_{i}_lig,  n. {cat_X_at_lst[1]} & org',
#         #         f'distance dist_{i}, pair_{i}_prot, pair_{i}_lig',
#         #         f'select pair_{i}, pair_{i}_prot | pair_{i}_lig',
#         #         f'label pair_{i}, "%s-%s-%s" % (name, resn, resi)' ]
#         # pmr(*cmds_pml)
#         # # VISU CONTACTS:
# t.prepare_kids()
# t.launch_kids()
# t.rdv('queue')
# t.exhaust_queue()
# type(t.rdv('status_history', if_not_exists=[]))
# status_history = t.rdv('status_history', if_not_exists=[])
#         t
# t.launch()


# t.XH_pdb.l
# t.kid.pld.pse.l
# t.kid.pld.make_visu()

# t.kid.kid.ls
# self
# self['1'].ls
# t.rdv('lit_at_pairs')
# t.XH_pdb.t
# self.unl_acpype['lig.mol2']
# self["ara.pdb"].t

# self.make_chd()
# self.run_hrx()
# self.o
# self.kid.launch()

# self.kid.prepare_kids()
# self.kid.kid.launch
# selfo

# self['prot.pdb'].t
# E_and_X_id_list
# [[250, 2478], [2030, 2496], [270, 2497], [273, 2498]]
# [[259, 2487], [2039, 2505], [279, 2506], [282, 2507]]

# self['X_atoms.pdb'].l
# self['E_atoms.pdb'].l
# self['npt.gro'].l
# self['vi_cnt.pse'].l
# self.make_chd()
# self.run_hrx()

# self.monitor_hrx_traj()

# if self.rdv(f'stage_{self.stage}_verdict'):
#     self.prepare_kids()
#     self.launch_kids()
# self.kid.launch()
# t.kid.kid.kid.decoys[0].l
# hjGo


# self.unl_acpype['ligand_after_4_charged.mol2'].t
# self.pld.pse.l
# self.kid.launch()
# self.pld.
# !conda install csv
# self.kid['str'].ls
# self.kid.
# import csv

# t.rm()
# t.launch()
# self.pld.pse


# t.launch()
# t.kid.kid.kid.kid.kid.stage
# t.kid.kid.kid.kid.kid.launch()
# t.kid.kid.kid.kid.kid.r

# self.make_visu()
# self.pld.pse.l

# t.kid.kid
# self.rdv('residues_to_mutate')
# self.launch()
# self.kid.rdv('decs2muts_df')
# self
# a
# self.launch()
# self.kid.rdv
# self.launch()
# P('/home/domain/data/rustam/A1/L_PI35P/PL_0__1/plantsconfig_pld_results_c_A_n_10000_flex_0').t
# self.pld.mol2s
# self.plds[1].get_bestranking_dict

# import csv
# csv_reader = csv.reader(open(self.plds[1]['ranking.csv'].s, 'r'))
# ll = np.array([i for i in csv_reader])

# Y = ll[1:, 1][::100]
# X = np.arange(len(Y))
# plt.plot(X, Y)
# [parent_depth.idxparent_depth in range(2 + 1)]
# t.kid.coords
# t.kid.kid.coords
# t.kid.stage
# t.kid
# min(Y), max(Y)
# self.launch()
# self.plds[0].ls
# self.plds[0]['ranking.csv'].t
# self.plds[2]['ranking.csv'].t
# self
# for cnf_id in range(10000):
#    se.idx 
#     self._id
# t.rdv('queue')
#     literature_cat_at_constraints = self.generate_literature_cat_at_constraints()
#     self.write_config_2(f'D1-0-{cnf_id}', literature_cat_at_constraints, n_struct=10, auto_name=False, flush_out_dir_names=False)

import csv
csv_reader = csv.reader(open(iti['ranking.csv'].s, 'r'))
bestranking_csv_dict = dict(zip(*[i for i in csv_reader]))
return(bestranking_csv_dict)




iti = Pld(self[it[0]])
ranking = iti.get_ranking()
dir(iti)

iti.get_ranking_array()
dir(csv_reader)

import csv
it = self.rdv('out_dir_names')


csv_reader = csv.reader(open(iti['ranking.csv'].s, 'r'))
np_array = np.array([*csv_reader])
np_array
k = pd.DataFrame(np_array[1:, 1:], columns=np_array[0, 1:], index=np_array[1:, 0])

k.index
k.iloc[0].index
dir(k.iloc[0])
k.reindex()
k.reset_index(drop=True, inplace=True)
k.reset_index(drop=True)
k.reindex(k.columns[0])

display(k)
k.index
[*k.index]
display(k)
np_array[0]



self_total_scores_df = iti.get_ranking()
self_total_scores_df

itiget_ranking
i
iti = P

[iti.name, total_scores_i]
d_i
t.kid.analyze_plants_results_PL__1()

ar = t.kid.rdv('total_scores')


self.analyze_plants_results_PL__1()


self
t.kid.kids
ar2 = []
for i1 in ar:
    for i3, i2 in enumerate(i1[1:]):
        ar2.append([i1[0], int(i3), float(i2)])
tot_scores_arr = np.array(ar2, dtype=object)
tot_scores_arr = tot_scores_arr.sort(key=lambda x: x[-1])
tot_scores_arr


ar
npc = np.array(ar[:, 1:], dtype=float)
np.dstack(np.unravel_index(np.argsort(npc.ravel()), npc.shape))


np.reshapel
np.argsort()
t.kid.rd

# TODO choosing directories before inflection point programmatically
# wnds = np.array_split(total_scores, 20)
# slopes = [stats.linregress(np.arange(len(wnd)), wnd).slope for wnd in wnds]
# slopes_centered = slopes / np.mean(slopes)
# my_plot(slopes_centered, "slopes_centered", "Номер результата докинга", "Скор программы PLANTS", "Результаты PLANTS, cluster_structures=10, ~2 000 запусков")



# assert len(total_scores) > 1000
# total_scores_x = np.arange(len(total_scores))
# total_scores

# # http://www.indianalytics.de/?p=41
# # Ищем перегиб функции
# # методом наименьших квадратов
# # большим окошком ползем
# # ищемкоэф.передх
# # если изменяется кратно или с трешхолдом -  то значит нашли
# # длина окошка
# # берем динамически или статически из участка до перегиба?
# # что будет, если нет перегиба?
# # если берем максимум диффов, то должен ли он быть в какой-то части графика?
# # кластеризовать надо ли ?

# numpy.diff



# c

# c = fabric.Connection ?


# emc('(kill-new)')
# cur_ser

# glv.run('ls')
# glv.cp(''kj;lkj;lkj;lkj')
# glv.cp("akjk")

#         copy_text_file_name = P("/tmp/copy_text_{server.a_host_alias}")
#         copy_text_file_name.write_text(text_)
# far_cmd = f"""
# emacsclient -s "{cur_ser.d_hes}/ge0" --eval '(load-file "{emc_cmd_file_name}")'
# """
# glv.cp("hello")

# cmd_ = "ava"
# emc_cmd_file_name = P(f"/tmp/emc_cmd_{cur_ser.a_ola}")
# emc_cmd_file_name.write_text(cmd_)
# emc_cmd_file_name = P(f"/ssh:{cur_ser.a_host_alias}:/tmp/emc_cmd_{cur_ser.a_ola}")
# far_cmd = f"""
# emacsclient -s "{cur_ser.d_hes}/ge0" --eval '(load-file "{emc_cmd_file_name}")'
# """
# far_cmd.strip("\n ")
# glv.a_ola

# glv.cp("AAV")
# t.kid.pld.ls

# total_scores

# str(name)

# t.rdv('queue')

# st = [
# [0, 0],
# [0, 1],
# [0, 0, 0],
# [0, 0, 0, 2],
# [0, 0, 3, 0],
# [0, 4, 0, 0],
# ]

# st.sort
# k = np.array([1, 2])
# k2 = np.array([1, 0])
# k3 = np.array([1, 0])
# np.array([1,0]) < np.array([3, 0, 4])
t.rdv('queue')

self.k

t.
self.par_pld['plds'][self.par_mol2_idx]



self

t.kid.kid
t.kid
import modeller
modeller
self.rdv('rnd_')
self.launch()

from modeller import physical, IOData

from modeller import log, physical, IOData
! pipinstallIOData
import 

from modeller import IOData

import iodata
iodata.IOData
import modeller.GroupRestraints

from modeller import *
GroupRestraints
from modeller import physical, group_restraints, energy_data, modfile
from modeller import physical, group_restraints, energy_data, modfile
from mo

        from modeller import group_restraints

dir(group_restraints)
self.run('acpype -b unl -i /mnt/scratch/users/fbbstudent/work/rustam/A1/L_PI35P/PL_0__1/HR_0__2/lig.mol2 --charge_method user --net_charge -5 -a gaff')
self.launch()

from modeller import *
self.mutate_protein()

from ..modeller.automodel.loopmodel import LoopModel

self
self.make_cv_table()
self.prepare_plumed()
self.run_hrx()
self.stop_hrx()
cur_ser.run()


self.gg

np.histogram2d([1, 2, 1, 243,100,99090,909,9090], [1, 2, 1, 243,100,99090,909,9090], bins=[[0.2, 1, 2, 3],[0.2, 1, 2, 3] ])
np.histogram2d



    file_path_split = file_path.read_text().split('\n')
    file_path_split_corred = [i for i in file_path_split if not i.startswith('#')]
    list_ = []
    list_all = []
    for line in file_path_split_corred:
        line_split = line.split();
        if len(line_split) == 0:
            list_all.append(list_)
            list_ = []
        else:
            arr = np.array([float(i) for i in line.split()])
            list_.append(arr)
    arr_all = np.array([np.array(j) for j in list_all])
    return(arr_all)




histoB_arr
E.ara
ara3()
histoB_arr

arr = histoB_arr[:, :, 0:2]
bins_cv_1, bins_cv_2 = arr[0, :, 0], arr[:, 0, 1]
bins_cv_1_corred = np.array([bins_cv_1[i: i + 2].mean() for i in range(bins_cv_1[:-1].shape[0])])
bins_cv_2_corred = np.array([bins_cv_2[i: i + 2].mean() for i in range(bins_cv_2[:-1].shape[0])])



mcv = t.kid['HR_10__2'].rdv('min_coords_values')
mcv
bins_cv_2_corred

np.histogram2d()


t_bias_x_rmsd_c[]
